<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programming on It&#39;s Ronald</title>
    <link>http://itsronald.com/categories/programming/</link>
    <description>Recent content in Programming on It&#39;s Ronald</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 16 Oct 2016 15:38:42 -0700</lastBuildDate>
    <atom:link href="http://itsronald.com/categories/programming/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>My First Android Library, Part I</title>
      <link>http://itsronald.com/blog/2016/10/my-first-library/</link>
      <pubDate>Sun, 16 Oct 2016 15:38:42 -0700</pubDate>
      
      <guid>http://itsronald.com/blog/2016/10/my-first-library/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/ronaldsmartin/Material-ViewPagerIndicator&#34;&gt;I built a software library recently&lt;/a&gt;. It&amp;rsquo;s a page indicator for mobile apps; the kind you&amp;rsquo;ve probably seen before with dots that change color to show what page you&amp;rsquo;re on. The one I made replicates Google&amp;rsquo;s latest iteration of this pattern with &lt;a href=&#34;https://material.google.com/&#34;&gt;Material Design&lt;/a&gt; inspiration. It&amp;rsquo;s really rather cool looking, I think:&lt;/p&gt;




    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;http://itsronald.com/img/2016/10/material-viewpagerindicator-1.0.0.gif&#34; alt=&#34;Material ViewPagerIndicator capture&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    



&lt;p&gt;As you can see, each dot represents a page, where the white dot is the current page and the gray dots are the other pages. When we change pages, the white selected dot page moves along a little path to the new current page.&lt;/p&gt;

&lt;p&gt;Anyway, I wanted to use something like this in another app I was making, but alas, there isn&amp;rsquo;t an official version available to the developer public. I found that Nick Butcher, a developer at Google, has &lt;a href=&#34;https://github.com/nickbutcher/plaid/blob/master/app/src/main/java/io/plaidapp/ui/widget/InkPageIndicator.java&#34;&gt;a version of his own&lt;/a&gt; included in a Material Design sample app, which as of this writing is pretty much as close to official as it gets. Sure, I could borrow that class, but&amp;hellip; could I make my own version?&lt;/p&gt;

&lt;p&gt;There is a first obvious question whenever you&amp;rsquo;re considering doing something like this.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Why reinvent the wheel?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Today&amp;rsquo;s Answer: Because we want to know how the wheel works, of course.&lt;/p&gt;

&lt;h2 id=&#34;breaking-down-the-animation:bb8325dde20c6cba93eb4b4bcafee07a&#34;&gt;Breaking down the animation&lt;/h2&gt;

&lt;p&gt;The first thing I had to do was figure out how the animation works. The natural first attempt relied on what I could observe with my own eyes, but eventually I found some other tools that helped me comprehend the animation in greater detail.&lt;/p&gt;

&lt;h3 id=&#34;tool-1-eyeballs:bb8325dde20c6cba93eb4b4bcafee07a&#34;&gt;Tool #1: Eyeballs&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s take a look at what we have here. Here&amp;rsquo;s the first official example I found from the &lt;em&gt;Google Opinion Rewards&lt;/em&gt; app (as of the time of the library&amp;rsquo;s creation, this was actually the only Google Android app on my phone that was using the indicator, despite its appearance elsewhere; others are using a version that does not animate).&lt;/p&gt;




    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;http://itsronald.com/img/2016/10/ink-indicator-example.gif&#34; alt=&#34;Material ViewPagerIndicator zoomed&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    



&lt;p&gt;Perhaps you&amp;rsquo;ll agree with me that from our high-level human standpoint, it appears pretty simple. You can already catch a lot more detail than I originally glean from blowing up the image, but here&amp;rsquo;s what I figured out from staring at that the tiny version on my phone for embarassingly long:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The dot for the current page makes a path to the dot for the new page.&lt;/li&gt;
&lt;li&gt;The white current page dot slides along the path to its new location.&lt;/li&gt;
&lt;li&gt;The path that was created shrinks back under the white current page dot.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Is that all we need to do to replicate this effect? How can we break this down in more detail?&lt;/p&gt;

&lt;h3 id=&#34;tool-2-gif-frame-splitting:bb8325dde20c6cba93eb4b4bcafee07a&#34;&gt;Tool #2: .GIF frame splitting&lt;/h3&gt;

&lt;p&gt;My first attempt at breaking this down involved sticking an image I found on GitHub through a GIF splitter and looking at each frame in the GIF. I discovered that DavidPacioianu on GitHub extracted the indicator from Nick Butcher&amp;rsquo;s sample app (the one I mentioned at the beginning) and &lt;a href=&#34;https://github.com/DavidPacioianu/InkPageIndicator&#34;&gt;set it up as a separate library&lt;/a&gt;. In the repo README, he helpfully included &lt;a href=&#34;https://camo.githubusercontent.com/f85b29e899c98abef7ee93a27eb8abd92c707635/687474703a2f2f692e696d6775722e636f6d2f6652674458574b2e676966&#34;&gt;a GIF of the isolated animation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;(Truthfully, this journey almost ended upon me finding his version, but sometimes you really just need to satisfy your own curiousity and satsify the itch to build something.)&lt;/p&gt;

&lt;p&gt;I grabbed the image and ran it through &lt;a href=&#34;http://ezgif.com/split&#34;&gt;ezgif.com&amp;rsquo;s GIF splitter&lt;/a&gt;. This method, though crude, helped me update my animation analysis with a lot of the details that were too fast for me to catch with just the naked eye:&lt;/p&gt;




    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;http://itsronald.com/img/2016/10/inkpageindicator-GIF-breakdown.png&#34; alt=&#34;InkPageIndicator GIF breakdown&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    



&lt;ol&gt;
&lt;li&gt;Both the dot for the current page and the dot for the new page start stretching out toward each other.&lt;/li&gt;
&lt;li&gt;Those two dots form a path.&lt;/li&gt;
&lt;li&gt;The current page dot slides across the path to its new location.&lt;/li&gt;
&lt;li&gt;The path retreats from the last page dot to the new page dot, &lt;em&gt;taking the old dot for that page with it.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;While the path is retreating, a new dot for the last selected page grows out of where the last dot was taken.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Wow! It turns out there was a lot more going on than I had initially thought. After deciding that &lt;em&gt;no, I wouldn&amp;rsquo;t let the existence of this alternative library deter my learning experience&lt;/em&gt;, I now had enough information to get started.&lt;/p&gt;

&lt;h3 id=&#34;tool-3-animator-scale-developer-setting:bb8325dde20c6cba93eb4b4bcafee07a&#34;&gt;Tool #3: &amp;ldquo;Animator scale&amp;rdquo; Developer Setting&lt;/h3&gt;

&lt;p&gt;While using the GIF splitter helped me get started, I found out while building the library that there&amp;rsquo;s an even better way to go about this. Specifically, the largest benefit of the GIF breakdown approach is also a huge downside: the breakdown is made up of static images, so it&amp;rsquo;s very difficult to find out how long each animation takes. (It&amp;rsquo;s probably possible to calculate if you know the frame rate of the source image, but that&amp;rsquo;s a bit of a pain.)&lt;/p&gt;

&lt;p&gt;Anyhow, it turns out that you can actually &lt;em&gt;slow down animations&lt;/em&gt; globally across your Android device using the &lt;strong&gt;Animator scale&lt;/strong&gt; option in Android&amp;rsquo;s Developer Settings:&lt;/p&gt;




    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;http://itsronald.com/img/2016/10/animator-scale-developer-settings.gif&#34; alt=&#34;Animator scale developer setting&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    



&lt;p&gt;For the uninitiated, &lt;a href=&#34;https://developer.android.com/reference/android/animation/Animator.html&#34;&gt;&lt;code&gt;Animator&lt;/code&gt;&lt;/a&gt; is a core class from the &lt;a href=&#34;http://android-developers.blogspot.com/2011/02/animation-in-honeycomb.html&#34;&gt;animation framework introduced in Android Honeycomb&lt;/a&gt;. It represents an animation &amp;ldquo;which can be started, ended, and have [listeners].&amp;rdquo; So, by altering the &lt;strong&gt;Animator scale&lt;/strong&gt; setting, &lt;em&gt;any&lt;/em&gt; animation across the entire system that uses &lt;code&gt;Animator&lt;/code&gt;s to operate will have their natural duration scaled accordingly.&lt;/p&gt;

&lt;p&gt;Using this tool, we can now &lt;strong&gt;really&lt;/strong&gt; pick apart the animation we&amp;rsquo;re seeing. At an Animator scale of &lt;em&gt;10x&lt;/em&gt;, i.e., animations take ten times longer, we can see all the details in a working example of the official widget (source: &lt;em&gt;Google Opinion Rewards&lt;/em&gt; app). I&amp;rsquo;ve used Android Nougat&amp;rsquo;s multi-window feature to show this side by side with the version I made. Each animation is shown separately because Nougat doesn&amp;rsquo;t like simultaneous swipes on both apps:&lt;/p&gt;

&lt;p&gt;


    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;http://itsronald.com/img/2016/10/material-vpi_side-by-side_opinion-rewards.gif&#34; alt=&#34;Indicators 10x Side-by-side&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    

&lt;/p&gt;

&lt;p&gt;Cool, right? This breakdown ended up being really helpful when I was trying to match animation timing for the library (it&amp;rsquo;s pretty close, and it will get even better as the library develops!), which we will get into in a future post.&lt;/p&gt;

&lt;p&gt;Thanks for reading! See you next time.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kotlin&#39;s Computed Properties Are Just Methods</title>
      <link>http://itsronald.com/blog/2016/06/kotlin-get-property-vs-method/</link>
      <pubDate>Thu, 30 Jun 2016 19:26:34 -0700</pubDate>
      
      <guid>http://itsronald.com/blog/2016/06/kotlin-get-property-vs-method/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Note: this post assumes familiarity with Java language features and conventions. RxJava familiarity is useful, but not required.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I was curious today about the relationship of Kotlin&amp;rsquo;s computed properties and methods. They do very similar things, so are they implemented similarly? (&lt;em&gt;Spoiler: Yes. Yes they are.&lt;/em&gt;) Somehow, however, I also ended up drawing some conclusions on the semantics of reactive &lt;code&gt;Observable&lt;/code&gt; generation. Kotlin&amp;rsquo;s computed properties can be a powerful tool for expressing your program&amp;rsquo;s intent with &lt;code&gt;Observable&lt;/code&gt;s, but you should think twice before using them for that purpose.&lt;/p&gt;

&lt;h2 id=&#34;observable-methods-vs-members:e09a1ffbb09430de544056fda2fc6671&#34;&gt;Observable methods vs. members&lt;/h2&gt;

&lt;p&gt;The examples of &lt;a href=&#34;https://github.com/ReactiveX/RxJava/wiki&#34;&gt;RxJava&lt;/a&gt; usage I&amp;rsquo;ve seen online generally use factory methods to produce &lt;a href=&#34;http://reactivex.io/documentation/observable.html&#34;&gt;&lt;code&gt;Observable&lt;/code&gt;s&lt;/a&gt; consumed by their subscribers. For example, using &lt;a href=&#34;http://square.github.io/retrofit/&#34;&gt;Retrofit&lt;/a&gt;, we&amp;rsquo;d define an API call that returns an &lt;code&gt;Observable&lt;/code&gt;, and then later we could call this as a method on our generated service.&lt;/p&gt;

&lt;h3 id=&#34;observables-in-retrofit-example:e09a1ffbb09430de544056fda2fc6671&#34;&gt;Observables in Retrofit example&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Define a Retrofit API:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface GitHubService {
  @GET(&amp;quot;users/{user}/repos&amp;quot;)
  Observable&amp;lt;List&amp;lt;Repo&amp;gt;&amp;gt; listRepos(@Path(&amp;quot;user&amp;quot;) String user);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Use it while chaining &lt;code&gt;Observable&lt;/code&gt;s:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Retrofit retrofit = new Retrofit.Builder()
    .baseUrl(&amp;quot;https://api.github.com/&amp;quot;)
    .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
    .build();
GitHubService service = retrofit.create(GitHubService.class);

service.listRepos(&amp;quot;octocat&amp;quot;)
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(repos -&amp;gt; ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is not only very easy to understand, but pretty much the only way to do this because our &lt;code&gt;listRepos()&lt;/code&gt; method needs an argument. What if, however, we had some other method that takes no params? Could we then access an &lt;code&gt;Observable&lt;/code&gt; as a member on some other object instead of via one of its methods?&lt;/p&gt;

&lt;p&gt;It is in fact very possible to do something like this:&lt;/p&gt;

&lt;h4 id=&#34;a-observable-member-implementation:e09a1ffbb09430de544056fda2fc6671&#34;&gt;A: Observable Member Implementation&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;public class Stopwatch {
    public final Observable&amp;lt;Long&amp;gt; currentTime = Observable.interval(1, TimeUnit.SECONDS);
}

...
// Using it:
Stopwatch stopwatch = new Stopwatch();
stopwatch.currentTime.subscribe(...);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;whereas a more traditional implementation would look like this:&lt;/p&gt;

&lt;h4 id=&#34;b-observable-method-implementation:e09a1ffbb09430de544056fda2fc6671&#34;&gt;B: Observable Method Implementation&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;public class Stopwatch {
    public Observable&amp;lt;Long&amp;gt; start() {
    	return Observable.interval(1, TimeUnit.SECONDS);
    }
}

// Using it:
Stopwatch stopwatch = new Stopwatch();
stopwatch.start().subscribe(...);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are a few things about the previous that I think are worth pointing out:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;What if, in either implementation, we had marked the &lt;code&gt;Observable&lt;/code&gt; as &lt;code&gt;static&lt;/code&gt;? I&amp;rsquo;ll leave that for you to think about, but honestly I think that there aren&amp;rsquo;t any startling differences between static/non-static &lt;code&gt;Observable&lt;/code&gt;s and static/non-static objects of other types.&lt;/li&gt;
&lt;li&gt;It&amp;rsquo;s interesting to note the semantic change between using a field and using a method. I tried to highlight this by naming them differently: &lt;code&gt;currentTime&lt;/code&gt; (a noun) versus &lt;code&gt;start()&lt;/code&gt;, a verb. Both &lt;code&gt;Observable&lt;/code&gt;s are doing the same thing, but in the first case, we imply that &lt;code&gt;currentTime&lt;/code&gt; is an observable property of a &lt;code&gt;Stopwatch&lt;/code&gt;, while in the second it is an operation that can be observed.&lt;br/&gt;
&lt;em&gt;(Giving them the same name felt unnatural to me. I was taught that variable names should be nouns and method names should be verbs, and in fact &lt;a href=&#34;http://www.oracle.com/technetwork/java/codeconventions-135099.html&#34;&gt;in this old Sun Java code convention guide&lt;/a&gt; it is suggested thus for methods. Interestingly, however, they omit going so far as to suggest similarly giving variables noun names as well. Maybe we can think about this another time.)&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;In the member implementation (&lt;strong&gt;A&lt;/strong&gt;), the single instance variable &lt;code&gt;currentTime&lt;/code&gt; is marked &lt;code&gt;final&lt;/code&gt;. I did this in order to provide functional equivalence to the second implementation (&lt;strong&gt;B&lt;/strong&gt;), but are there cases in which an observable member ought to be mutable?&lt;br/&gt;
If the &lt;code&gt;Stopwatch&lt;/code&gt; class had some other state &lt;code&gt;precision&lt;/code&gt; that controlled the interval&amp;rsquo;s &lt;code&gt;TimeUnit&lt;/code&gt; (instead of the hardcoded &lt;code&gt;TimeUnit.SECONDS&lt;/code&gt;), the member &lt;code&gt;currentTime&lt;/code&gt; would need to be reassigned to reflect the new value, and thus could not be marked &lt;code&gt;final&lt;/code&gt;.&lt;br/&gt;
If the &lt;code&gt;currentTime&lt;/code&gt; was no longer &lt;code&gt;final&lt;/code&gt;, it would be susceptible to arbitrary reassignment. How can we protect against this? In Java, we would mark it &lt;code&gt;private&lt;/code&gt;, and then provide getter access via a getter method, and then&amp;hellip; wait. That just results in a modified version of &lt;strong&gt;B&lt;/strong&gt;!
Thus, if you know your &lt;code&gt;Observable&lt;/code&gt; might need to change, you&amp;rsquo;re probably better off just using a method.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;kotlin-computed-properties-are-functions:e09a1ffbb09430de544056fda2fc6671&#34;&gt;Kotlin computed properties are functions&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s get to what got me curious about in the first place. Say you have a class like &lt;code&gt;Stopwatch&lt;/code&gt; that has some state you&amp;rsquo;d like to observe. Additionally, you aren&amp;rsquo;t restricted by the need for a parameter like the GitHub username in our very first example. Should you be using the approach A with some observable property, or approach B with methods?&lt;/p&gt;

&lt;h3 id=&#34;computed-properties:e09a1ffbb09430de544056fda2fc6671&#34;&gt;Computed properties&amp;hellip;&lt;/h3&gt;

&lt;p&gt;Kotlin has a number of features that expand what is possible in Java. For the question posed above, I am particularly interested in what I&amp;rsquo;m going to call a &lt;em&gt;computed property&lt;/em&gt; (name taken from the equivalent feature in Swift): a field on an object that does not actually store a value, but instead uses a custom getter (and optionally, a setter) to implement normal property access. Let&amp;rsquo;s illustrate this with an example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Person(
    var firstName: String,   // Standard property with synthesized get-set accessors
    var lastName: String) {  // Another standard property
    
    /**
     * Our computed property! Instead of storing a value, it computes one by calling the
     * getter we implement.
     * This is a read-only computed property defined using `val` instead of `var`.
     */
    val fullName: String
        get() = &amp;quot;$firstName $lastName&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Both computed and non-computed properties are accessed the same way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val person = Person(firstName = &amp;quot;Monica&amp;quot;, lastName = &amp;quot;Geller&amp;quot;)
person.firstName // &amp;quot;Monica&amp;quot;
person.lastName  // &amp;quot;Geller&amp;quot;
person.fullName  // &amp;quot;Monica Geller&amp;quot;

person.lastName = &amp;quot;Bing&amp;quot;
person.fullName  // &amp;quot;Monica Bing&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hopefully that makes sense. For another illustrative example, check out the section on computed properties in the &lt;a href=&#34;(https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID259&#34;&gt;Swift Programming Language Guide&lt;/a&gt;) and its subsequent section on read-only computed properties here. For more on Kotlin properties, &lt;a href=&#34;https://kotlinlang.org/docs/reference/properties.html&#34;&gt;check out the appropriate Kotlin page&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;can-be-used-like-factory-functions:e09a1ffbb09430de544056fda2fc6671&#34;&gt;&amp;hellip;can be used like factory functions&lt;/h3&gt;

&lt;p&gt;Now, we don&amp;rsquo;t &lt;em&gt;have&lt;/em&gt; to compute our property value from other object properties. Let&amp;rsquo;s look at a familiar example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Stopwatch() {
    val currentTime: Observable&amp;lt;Long&amp;gt; 
        get() = Observable.interval(1, TimeUnit.SECONDS)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yes, it&amp;rsquo;s our &lt;code&gt;Stopwatch&lt;/code&gt; example &lt;strong&gt;A&lt;/strong&gt; from before. Obviously, we can also implement the alternate implementation &lt;strong&gt;B&lt;/strong&gt; in Kotlin as well:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Stopwatch() {
    // In Kotlin, a function that returns an expression does not need to be 
    // enclosed in braces or explicit use of the `return` keyword.
    fun start(): Observable&amp;lt;Long&amp;gt; = Observable.interval(1, TimeUnit.SECONDS)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is hardly any change to our Java code when it comes to actual usage, too:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val stopwatch = Stopwatch()

// Version A
stopwatch.currentTime.subscribe { ... } // Using Kotlin syntax for trailing lambdas

// Version B
stopwatch.start().subscribe { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;are-recalculated-on-each-access:e09a1ffbb09430de544056fda2fc6671&#34;&gt;&amp;hellip;are recalculated on each access&lt;/h3&gt;

&lt;p&gt;Notably, the read-only computed property approach does &lt;em&gt;not&lt;/em&gt; have one of the same issues as the &lt;code&gt;public final&lt;/code&gt; field approach in Java. Earlier we noted that if an &lt;code&gt;Observable&lt;/code&gt; field depends on some kind of external state, the &lt;code&gt;public final&lt;/code&gt; approach is untenable because the field would need reassignment in order to generate a modified &lt;code&gt;Observable&lt;/code&gt;. Since a computed property uses its getter to generate a new value each time it is accessed, it is &amp;ldquo;reassigned&amp;rdquo; each time it is called.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at an example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Stopwatch() {
    
    /** Some modifiable state that the Observables depend on */
    var precision = TimeUnit.SECONDS

    // Version A
    val currentTime: Observable&amp;lt;Long&amp;gt; 
        get() = Observable.interval(1, precision)

    // Version B
	fun start(): Observable&amp;lt;Long&amp;gt; = Observable.interval(1, precision)
}

// Usage:
val stopwatch = Stopwatch()

// Both return a subscription to `Observable.interval(1, TimeUnit.SECONDS)`
stopwatch.currentTime.subscribe { ... } // Version A
stopwatch.start().subscribe { ... }     // Version B

stopwatch.precision = TimeUnit.MINUTES

// Now both return subscriptions to `Observable.interval(1, TimeUnit.MINUTES)`
stopwatch.currentTime.subscribe { ... } // Version A
stopwatch.start().subscribe { ... }     // Version B
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, both versions end up producing the same value. Furthermore, &lt;strong&gt;A&lt;/strong&gt; is &lt;em&gt;not&lt;/em&gt; subject to arbitrary replacement by some other &lt;code&gt;Observable&lt;/code&gt; &amp;ndash; it is marked as read-only (&lt;code&gt;val&lt;/code&gt;) and cannot be reassigned.&lt;/p&gt;

&lt;h3 id=&#34;are-in-fact-just-functions:e09a1ffbb09430de544056fda2fc6671&#34;&gt;&amp;hellip;are in fact just functions?&lt;/h3&gt;

&lt;p&gt;Intuitively, it makes sense that a read-only computed property is just some syntactic sugar on top of methods. When you look at the property definition, the &lt;code&gt;get() = ...&lt;/code&gt; is literally defining a custom getter method to be used for property access. What does its declaration indicate?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val currentTime: Observable&amp;lt;Long&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can read that as &amp;ldquo;if you access me on/give me an object instance, I will give you an &lt;code&gt;Observable&amp;lt;Long&amp;gt;&lt;/code&gt;.&amp;rdquo; In mathematical terminology, a relation that maps an input to an output is called a &lt;strong&gt;function&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Are all properties just functions inside?&lt;/em&gt; The conspiracy deepens.&lt;/p&gt;

&lt;h3 id=&#34;are-indeed-functions-under-the-hood:e09a1ffbb09430de544056fda2fc6671&#34;&gt;&amp;hellip;are indeed functions under the hood&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s check this out. It&amp;rsquo;s possible that there&amp;rsquo;s some subtle difference here that might contribute to our &amp;ldquo;property vs method&amp;rdquo; debate. Maybe there is some overhead in using computed properties&amp;hellip; or will it be the other way around? This is the question that inspired this post, and &lt;em&gt;we will find the answer&lt;/em&gt;!&lt;/p&gt;

&lt;p&gt;In all seriousness, it&amp;rsquo;s pretty easy to find out. I propose a simple test: look at the code generated from each of the property and function implementations and see how both differ.&lt;/p&gt;

&lt;h4 id=&#34;example-kotlin-class:e09a1ffbb09430de544056fda2fc6671&#34;&gt;Example Kotlin class:&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;import rx.Observable
import java.util.concurrent.TimeUnit

class Stopwatch() {
    
    /** Some modifiable state that the Observables depend on */
    var precision = TimeUnit.SECONDS

    // Version A
    val currentTime: Observable&amp;lt;Long&amp;gt; 
        get() = Observable.interval(1, precision)

    // Version B
	fun start(): Observable&amp;lt;Long&amp;gt; = Observable.interval(1, precision)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Kotlin plugin to IntelliJ provides a nifty feature that lets you look at the Java bytecode generated from any given Kotlin code. You can access this easily by tapping Cmd+Shift+A and typing in &amp;ldquo;bytecode.&amp;rdquo;&lt;/p&gt;




    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;http://itsronald.com/img/2016/06/kotlin-bytecode-viewer-android-studio.png&#34; alt=&#34;Kotlin Bytecode Viewer&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    



&lt;p&gt;Here is the generated bytecode for our Observables in the class above using Android Studio 2.2-Preview 4 and Kotlin v1.0.2-1:&lt;/p&gt;

&lt;h4 id=&#34;stopwatch-kt-bytecode-for-currenttime-and-start:e09a1ffbb09430de544056fda2fc6671&#34;&gt;Stopwatch.kt bytecode for &lt;code&gt;currentTime&lt;/code&gt; and &lt;code&gt;start()&lt;/code&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  // access flags 0x11
  // signature ()Lrx/Observable&amp;lt;Ljava/lang/Long;&amp;gt;;
  // declaration: rx.Observable&amp;lt;java.lang.Long&amp;gt; getCurrentTime()
  public final getCurrentTime()Lrx/Observable;
  @Lorg/jetbrains/annotations/NotNull;() // invisible
   L0
    LINENUMBER 13 L0
    LCONST_1
    ALOAD 0
    GETFIELD com/itsronald/twenty2020/base/Stopwatch.precision : Ljava/util/concurrent/TimeUnit;
    INVOKESTATIC rx/Observable.interval (JLjava/util/concurrent/TimeUnit;)Lrx/Observable;
    DUP
    LDC &amp;quot;Observable.interval(1, precision)&amp;quot;
    INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkExpressionValueIsNotNull (Ljava/lang/Object;Ljava/lang/String;)V
    ARETURN
   L1
    LOCALVARIABLE this Lcom/itsronald/twenty2020/base/Stopwatch; L0 L1 0
    MAXSTACK = 3
    MAXLOCALS = 1

  // access flags 0x11
  // signature ()Lrx/Observable&amp;lt;Ljava/lang/Long;&amp;gt;;
  // declaration: rx.Observable&amp;lt;java.lang.Long&amp;gt; start()
  public final start()Lrx/Observable;
  @Lorg/jetbrains/annotations/NotNull;() // invisible
   L0
    LINENUMBER 16 L0
    LCONST_1
    ALOAD 0
    GETFIELD com/itsronald/twenty2020/base/Stopwatch.precision : Ljava/util/concurrent/TimeUnit;
    INVOKESTATIC rx/Observable.interval (JLjava/util/concurrent/TimeUnit;)Lrx/Observable;
    DUP
    LDC &amp;quot;Observable.interval(1, precision)&amp;quot;
    INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkExpressionValueIsNotNull (Ljava/lang/Object;Ljava/lang/String;)V
    ARETURN
   L1
    LOCALVARIABLE this Lcom/itsronald/twenty2020/base/Stopwatch; L0 L1 0
    MAXSTACK = 3
    MAXLOCALS = 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s a bit hard to parse, though the bytecode doesn&amp;rsquo;t look terribly different. Perhaps this will be clearer if we decompile this back into Java using the sweet new &lt;strong&gt;Decompile&lt;/strong&gt; button on top here:&lt;/p&gt;




    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;http://itsronald.com/img/2016/06/kotlin-decompile-button.png&#34; alt=&#34;Kotlin Bytecode Viewer&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    



&lt;h4 id=&#34;stopwatch-decompiled-java:e09a1ffbb09430de544056fda2fc6671&#34;&gt;Stopwatch.decompiled.java&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;import java.util.concurrent.TimeUnit;
import kotlin.Metadata;
import kotlin.jvm.internal.Intrinsics;
import org.jetbrains.annotations.NotNull;
import rx.Observable;

@Metadata(
    // Some generated metadata
)
public final class Stopwatch {
   @NotNull
   private TimeUnit precision;

   @NotNull
   public final TimeUnit getPrecision() {
      return this.precision;
   }

   public final void setPrecision(@NotNull TimeUnit &amp;lt;set-?&amp;gt;) {
      Intrinsics.checkParameterIsNotNull(&amp;lt;set-?&amp;gt;, &amp;quot;&amp;lt;set-?&amp;gt;&amp;quot;);
      this.precision = &amp;lt;set-?&amp;gt;;
   }

   @NotNull
   public final Observable getCurrentTime() {
      Observable var10000 = Observable.interval(1L, this.precision);
      Intrinsics.checkExpressionValueIsNotNull(var10000, &amp;quot;Observable.interval(1, precision)&amp;quot;);
      return var10000;
   }

   @NotNull
   public final Observable start() {
      Observable var10000 = Observable.interval(1L, this.precision);
      Intrinsics.checkExpressionValueIsNotNull(var10000, &amp;quot;Observable.interval(1, precision)&amp;quot;);
      return var10000;
   }

   public Stopwatch() {
      this.precision = TimeUnit.SECONDS;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Surprise, surprise. &lt;code&gt;currentTime&lt;/code&gt; and &lt;code&gt;start()&lt;/code&gt;, and their generated counterparts &lt;code&gt;getCurrentTime()&lt;/code&gt; and &lt;code&gt;start()&lt;/code&gt;, have &lt;strong&gt;exactly&lt;/strong&gt; equal implementations. They are the same except for their names! While we used a bit of a trivial example, I also went ahead and tried this with some much more complex &lt;code&gt;Observable&lt;/code&gt;s and ended up with the same result.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Read-only computed properties are just functions under the hood.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;so-which-way-do-i-use:e09a1ffbb09430de544056fda2fc6671&#34;&gt;So&amp;hellip; which way do I use?&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s do a quick comparison.&lt;/p&gt;

&lt;h3 id=&#34;java:e09a1ffbb09430de544056fda2fc6671&#34;&gt;Java&lt;/h3&gt;

&lt;p&gt;In pure Java, you are almost certainly better off using the method implementation of &lt;code&gt;Observable&lt;/code&gt; generation. There is a reason that you fairly exclusively see this practice in examples, and it all comes down to safe usage patterns through encapsulation.&lt;/p&gt;

&lt;p&gt;As a reminder, exposing an &lt;code&gt;Observable&lt;/code&gt; field on an object:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Allows unsafe assignment unless marked &lt;code&gt;final&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Make it unable to adapt to changes to its enclosing object&amp;rsquo;s other fields if marked &lt;code&gt;final&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Can&amp;rsquo;t take or use arguments.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Methods, on the other hand:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Are immutable&lt;/li&gt;
&lt;li&gt;Generate their return values when called and thus react to changes in their enclosing objects&amp;rsquo; other fields&lt;/li&gt;
&lt;li&gt;Can have arguments.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;kotlin:e09a1ffbb09430de544056fda2fc6671&#34;&gt;Kotlin&lt;/h3&gt;

&lt;p&gt;Kotlin&amp;rsquo;s property syntax allows a very different style of programming than when only using Java. As we&amp;rsquo;ve found, using a computed property gives us the power of a getter method with the access pattern of an object field.&lt;/p&gt;

&lt;p&gt;With regard to data generation, computed properties:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Do not allow unsafe reassignment&lt;/li&gt;
&lt;li&gt;Generate their return values when called and thus react to changes in their enclosing objects&amp;rsquo; other fields&lt;/li&gt;
&lt;li&gt;Still can&amp;rsquo;t take arguments.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I submit that perhaps, then, computed properties are a solid alternative to methods for many data types. Certainly they have the capacity to clarify the intent of our programs. If your computed property is just a thin API that provides access to an in-memory field, you should definitely be using it instead of a method.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;However&amp;hellip;&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;observables-aren-t-simple-data-types:e09a1ffbb09430de544056fda2fc6671&#34;&gt;Observables aren&amp;rsquo;t simple data types&lt;/h4&gt;

&lt;p&gt;Most &lt;code&gt;Observable&lt;/code&gt; objects are complex and expensive to create. If your computed property instantiates a new Observable every time it&amp;rsquo;s accessed, using a method better signals that we are building a new object that shouldn&amp;rsquo;t be used carelessly.&lt;/p&gt;

&lt;h4 id=&#34;some-observables-have-side-effects:e09a1ffbb09430de544056fda2fc6671&#34;&gt;Some Observables have side effects&lt;/h4&gt;

&lt;p&gt;If the &lt;code&gt;Observable&lt;/code&gt; you expose as a property implements &lt;a href=&#34;http://reactivex.io/documentation/operators/do.html&#34;&gt;&lt;code&gt;doOnNext()&lt;/code&gt;&lt;/a&gt;, you have now introduced unknown side effects in what is supposed to be a simple data access.&lt;/p&gt;

&lt;p&gt;Or, if you have assigned a &lt;a href=&#34;http://reactivex.io/documentation/scheduler.html&#34;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; to the &lt;code&gt;Observable&lt;/code&gt;, you may have just created a new thread, unbeknownst to the caller! When using a method, there is an implicit understanding that the code body might just do more than accessing a value.&lt;/p&gt;

&lt;h4 id=&#34;observables-are-inherently-asynchronous:e09a1ffbb09430de544056fda2fc6671&#34;&gt;Observables are inherently asynchronous&lt;/h4&gt;

&lt;p&gt;Asynchronous interactions are notoriously difficult to reason about. The &lt;code&gt;Observable&lt;/code&gt; class is meant to ease some of the cognitive load on the programmer, but it still remains that they represent some kind of potential asynchronous value. This leads back to the first point that &lt;em&gt;Observables aren&amp;rsquo;t simple&lt;/em&gt; and that &lt;em&gt;methods better reflect their complexity&lt;/em&gt;. In fact, many common &lt;code&gt;Observable&lt;/code&gt;s represent long running operations, and actions an object takes are better represented as methods.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; A good resource I found on this subject is the &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/ms229054(v=vs.100&#34;&gt;MSDN guide on &amp;ldquo;Choosing Between Properties and Methods&amp;rdquo;&lt;/a&gt;.aspx).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TL;DR: Kotlin computed properties are just methods, but that doesn&amp;rsquo;t mean you should be using them to expose your object&amp;rsquo;s &lt;code&gt;Observable&lt;/code&gt; API.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Now it&amp;rsquo;s time for me to start migrating my computed Observables to straight methods&amp;hellip; :-P&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lessons Learned: Kotlin &#43; Dagger2</title>
      <link>http://itsronald.com/blog/2016/06/lessons-learned-kotlin-dagger2/</link>
      <pubDate>Tue, 14 Jun 2016 22:48:04 -0700</pubDate>
      
      <guid>http://itsronald.com/blog/2016/06/lessons-learned-kotlin-dagger2/</guid>
      <description>

&lt;h1 id=&#34;update-2016-10-05:8b618abf5a7523d1736f50f60d1b5347&#34;&gt;Update 2016-10-05&lt;/h1&gt;

&lt;p&gt;This article has been updated to reflect some changes to tooling that fixes some of the problems mentioned below.&lt;/p&gt;

&lt;h2 id=&#34;living-life-on-the-edge:8b618abf5a7523d1736f50f60d1b5347&#34;&gt;Living Life on the &amp;ldquo;Edge&amp;rdquo;&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;m currently building an Android app to remind me to take healthy breaks from starting at computer screens. For extra funsies, it&amp;rsquo;s built on the cutting edge of current fashionable Android technologies. Of particular note today, we have:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;MVP architecture using &lt;a href=&#34;http://google.github.io/dagger/&#34;&gt;Dagger 2&lt;/a&gt; for dependency injection, and&lt;/li&gt;
&lt;li&gt;Kotlin, the JVM language by JetBrains.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I&amp;rsquo;ve run into a few roadblocks along the way, and since we&amp;rsquo;re using shiny new tools, there&amp;rsquo;s fewer than usual online solutions addressing them. Hopefully these tips might help someone out there who&amp;rsquo;s doing something similar.&lt;/p&gt;

&lt;p&gt;At the time of writing, I&amp;rsquo;m currently using Dagger v2.2 with Kotlin v1.0.2. I have just discovered that Dagger 2.4 is &lt;a href=&#34;https://github.com/google/dagger/releases/tag/dagger-2.4&#34;&gt;already stable&lt;/a&gt; and that Dagger 2.5 was commited to master a few hours ago, so I&amp;rsquo;ll update this again when I&amp;rsquo;ve looked into whether using one of these instead of v2.2 addresses some of the issues that follow.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update 2016-10-05:&lt;/strong&gt; I have released the app that inspired this article. You can &lt;a href=&#34;https://github.com/ronaldsmartin/20twenty20&#34;&gt;check it out on GitHub&lt;/a&gt; as a reference when setting up your own project.&lt;/p&gt;

&lt;h3 id=&#34;kapt-the-kotlin-annotations-processor:8b618abf5a7523d1736f50f60d1b5347&#34;&gt;&lt;code&gt;kapt&lt;/code&gt;, the Kotlin annotations processor&lt;/h3&gt;

&lt;p&gt;Most of the tutorials on (Java) Dagger integrations rely on Hugo Visser&amp;rsquo;s &lt;a href=&#34;https://bitbucket.org/hvisser/android-apt&#34;&gt;Android Studio Annotations Processor&lt;/a&gt;. This is used with Dagger as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apply plugin: &#39;com.neenbedankt.android-apt&#39;

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath &#39;com.neenbedankt.gradle.plugins:android-apt:1.4&#39;
    }
}

android {
    ...
}

dependencies {
    apt &amp;quot;com.google.dagger:dagger-compiler:$rootProject.ext.daggerVersion&amp;quot;
    compile &amp;quot;com.google.dagger:dagger:$rootProject.ext.daggerVersion&amp;quot;
    provided &#39;javax.annotation:jsr250-api:1.0&#39; 

    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, when using these annotations in Kotlin files we should be using the built-in Kotlin annotation processor instead (source: &lt;a href=&#34;javax.annotation:javax.annotation-api&#34;&gt;Stack Overflow&lt;/a&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// apply plugin: &#39;com.neenbedankt.android-apt&#39; - no longer necessary

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        // classpath &#39;com.neenbedankt.gradle.plugins:android-apt:1.4&#39; - no longer necessary
    }
}

android {
    ...
}

kapt {
    generateStubs = true
}

dependencies {
    // apt &amp;quot;com.google.dagger:dagger-compiler:$rootProject.ext.daggerVersion&amp;quot; - use kapt instead
    kapt &amp;quot;com.google.dagger:dagger-compiler:$rootProject.ext.daggerVersion&amp;quot;
    compile &amp;quot;com.google.dagger:dagger:$rootProject.ext.daggerVersion&amp;quot;
    provided &#39;javax.annotation:jsr250-api:1.0&#39; 

    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;multiple-jsr-250-dependencies:8b618abf5a7523d1736f50f60d1b5347&#34;&gt;Multiple JSR 250 Dependencies&lt;/h3&gt;

&lt;p&gt;That &lt;code&gt;provided &#39;javax.annotation:jsr250-api:1.0&#39;&lt;/code&gt; line might have stuck out to you.&lt;/p&gt;

&lt;p&gt;Developers haven&amp;rsquo;t seemed to have agreed on a source for the &lt;a href=&#34;https://en.wikipedia.org/wiki/JSR_250&#34;&gt;JSR-250 Java annotations API&lt;/a&gt; used by the Dagger compiler. I&amp;rsquo;ve encountered at least three Gradle artifacts in various projects:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://bintray.com/bintray/jcenter/javax.annotation%3Ajavax.annotation-api/view&#34;&gt;&lt;code&gt;javax.annotation:javax.annotation-api:1.2&lt;/code&gt;&lt;/a&gt; - used in &lt;a href=&#34;https://github.com/sockeqwe/mosby&#34;&gt;Mosby&lt;/a&gt;&amp;rsquo;s Dagger sample; in Facebook&amp;rsquo;s &lt;a href=&#34;https://github.com/facebook/fresco&#34;&gt;Fresco library&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bintray.com/bintray/jcenter/org.glassfish%3Ajavax.annotation/10.0-b28/view#&#34;&gt;&lt;code&gt;org.glassfish:javax.annotation:10.0-b28&lt;/code&gt;&lt;/a&gt; - used in Google&amp;rsquo;s MVP+Dagger example and damianpetla&amp;rsquo;s Kotlin+Dagger example&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bintray.com/bintray/jcenter/javax.annotation%3Ajsr250-api/1.0/view&#34;&gt;&lt;code&gt;javax.annotation:jsr250-api:1.0&lt;/code&gt;&lt;/a&gt; - per codepath&amp;rsquo;s &lt;a href=&#34;https://github.com/codepath/android_guides/wiki/Dependency-Injection-with-Dagger-2&#34;&gt;Dagger 2 article&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So, what gives? A rudimentary Google search suggests that all of these were implemented as part of Sun/Oracle&amp;rsquo;s &lt;a href=&#34;https://en.wikipedia.org/wiki/GlassFish&#34;&gt;GlassFish project&lt;/a&gt;. I didn&amp;rsquo;t find what I was looking for in jCenter, so I found what I believe are the original uploads on good maven central. This is what I found:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://search.maven.org/#artifactdetails%7Cjavax.annotation%7Cjavax.annotation-api%7C1.2%7Cjar&#34;&gt;&lt;code&gt;javax.annotation:javax.annotation-api:1.2&lt;/code&gt;&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Description:&lt;/strong&gt; &amp;ldquo;Common Annotations for the JavaTM Platform API&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;URL (from metadata):&lt;/strong&gt; &lt;a href=&#34;https://jcp.org/en/jsr/detail?id=250&#34;&gt;https://jcp.org/en/jsr/detail?id=250&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Last updated:&lt;/strong&gt; 2013&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Main &lt;code&gt;.jar&lt;/code&gt; filesize:&lt;/strong&gt; 42311 bytes&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Includes developer in metadata:&lt;/strong&gt; Rajiv Mordani, the JSR-250 lead at Sun (and now at Oracle).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://search.maven.org/#artifactdetails%7Corg.glassfish%7Cjavax.annotation%7C10.0-b28%7Cjar&#34;&gt;&lt;code&gt;org.glassfish:javax.annotation:10.0-b28&lt;/code&gt;&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Description:&lt;/strong&gt; &amp;ldquo;Common Annotations for the JavaTM Platform API version ${spec.version} Repackaged as OSGi bundle in GlassFish&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;URL (from metadata):&lt;/strong&gt; None&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Last updated:&lt;/strong&gt; 2011&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Main &lt;code&gt;.jar&lt;/code&gt; filesize:&lt;/strong&gt; 20542 bytes&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Includes developer in metadata:&lt;/strong&gt; No&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Notes:&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Manifest includes in header: &amp;ldquo;Copyright 1997-2008 Sun Microsystems, Inc.&amp;rdquo;&lt;/li&gt;
&lt;li&gt;Lists #3 below as an optional dependency!&lt;/li&gt;
&lt;li&gt;OSGi (&lt;a href=&#34;https://www.osgi.org/developer/architecture/&#34;&gt;official site&lt;/a&gt;; &lt;a href=&#34;https://en.wikipedia.org/wiki/OSGi&#34;&gt;Wikipedia&lt;/a&gt;) is a standard for packaging Java components.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://search.maven.org/#artifactdetails%7Cjavax.annotation%7Cjsr250-api%7C1.0%7Cjar&#34;&gt;&lt;code&gt;javax.annotation:jsr250-api:1.0&lt;/code&gt;&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Description:&lt;/strong&gt; &amp;ldquo;JSR-250 Reference Implementation by Glassfish&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;URL (from metadata):&lt;/strong&gt; &lt;a href=&#34;https://jcp.org/aboutJava/communityprocess/final/jsr250/index.html&#34;&gt;https://jcp.org/aboutJava/communityprocess/final/jsr250/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Last updated:&lt;/strong&gt; 2007&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Main &lt;code&gt;.jar&lt;/code&gt; filesize:&lt;/strong&gt; 5848 bytes&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Includes developer in metadata:&lt;/strong&gt; No&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;According to the &lt;a href=&#34;https://jcp.org/en/jsr/detail?id=250&#34;&gt;community page&lt;/a&gt; (which is the same URL provided by #1), the original release was in 2006, with maintenance releases in 2009 and 2013 (n.b.: &lt;a href=&#34;https://jcp.org/aboutJava/communityprocess/maintenance/jsr250/JSR-250-MR3-changes.html&#34;&gt;another maintenance release&lt;/a&gt; is scheduled for next month, Jul 2016!). So it looks like #1, &lt;code&gt;javax.annotation:javax.annotation-api:1.2&lt;/code&gt; implements the latest version of this spec, whereas #3 implemented the first stable version almost ten years ago.&lt;/p&gt;

&lt;p&gt;For what it&amp;rsquo;s worth, I gave all of them a whirl with Dagger and didn&amp;rsquo;t run into any issues. This is a good enough comparison for my purposes short of peeking inside the JARs and comparing them. Since #3 is the smallest and seems to contain the bare minimum necessary for Dagger, I&amp;rsquo;ve taken to using that package.&lt;/p&gt;

&lt;h3 id=&#34;kotlin-android-extensions:8b618abf5a7523d1736f50f60d1b5347&#34;&gt;kotlin-android-extensions&lt;/h3&gt;

&lt;p&gt;JetBrains&amp;rsquo; &lt;a href=&#34;https://kotlinlang.org/docs/tutorials/android-plugin.html&#34;&gt;Kotlin Android Extensions&lt;/a&gt; plugin provides some great features on top of the standard tooling. For those who haven&amp;rsquo;t used it, it can create &amp;ldquo;synthetic properties&amp;rdquo; properties from your XML layout files so that you don&amp;rsquo;t need to make &lt;code&gt;findViewById()&lt;/code&gt; calls and cast them to assign your instance variables. These calls are the bane of Android developers everywhere, many of whom use &lt;a href=&#34;http://jakewharton.github.io/butterknife/&#34;&gt;ButterKnife&lt;/a&gt; to fight back:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Traditionally in Java:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class MyActivity extends Activity {

    private TextView mTextView;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        mTextView = (TextView) findViewById(R.id.textview);

        // Now you can use mTextView:
        mTextView.setText(&amp;quot;Hello, reader!&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;With ButterKnife (Still in Java):&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class MyActivity extends Activity {
    @BindView(R.id.textview) TextView textView;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        ButterKnife.bind(this);

        // Now you can use textView:
        textView.setText(&amp;quot;Hello, reader!&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;With kotlin-android-extensions:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import kotlinx.android.synthetic.main.activity_main.* // Import all views in R.layout.activity_main

class MyActivity: Activity() {
    override fun onCreate(savedInstanceState: Bundle) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // textview is already available
        textview.text = &amp;quot;Hello, reader!&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;dagger-2-2-compatibility:8b618abf5a7523d1736f50f60d1b5347&#34;&gt;Dagger 2.2 Compatibility&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Update 2016-10-05:&lt;/strong&gt; This seemed to be a problem with the Kotlin plugin rather than with Dagger itself. Code minify works fine with Kotlin v1.0.3 and the current version 1.0.4.&lt;/p&gt;

&lt;p&gt;Nice, right? &lt;em&gt;However&lt;/em&gt;, I couldn&amp;rsquo;t for the life of me make my view classes work with &lt;em&gt;both&lt;/em&gt; Dagger and Kotlin. I started out with an Activity that used Dagger for injecting its presenter. Then, I tried factoring out those pesky &lt;code&gt;findViewById()&lt;/code&gt; calls and using the synthetic properties directly, only to run into various build errors. Either the compiler couldn&amp;rsquo;t import the synthetic layout &amp;ldquo;&lt;code&gt;Unresolved reference kotlinx&lt;/code&gt;,&amp;rdquo; or component classes generated by Dagger &amp;ldquo;&lt;code&gt;references unknown class X&lt;/code&gt;,&amp;rdquo; where X is the component interface that Dagger used to generate it. Okay.&lt;/p&gt;

&lt;p&gt;This was oft accompanied by the sad error message:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;:app:transformClassesWithNewClassShrinkerForDebug FAILED&lt;/p&gt;

&lt;p&gt;Error:Execution failed for task &amp;lsquo;:app:transformClassesWithNewClassShrinkerForDebug&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;Warnings found during shrinking, please use -dontwarn or -ignorewarnings to suppress them.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The fix:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;buildTypes {
    yourBuildType {
        // ...
        minifyEnabled false
        // ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Voila. No more errors. Hope that gets fixed soon, though.&lt;/p&gt;

&lt;h4 id=&#34;misleading-solutions:8b618abf5a7523d1736f50f60d1b5347&#34;&gt;Misleading solutions&lt;/h4&gt;

&lt;p&gt;While trying to fix the problem above, Googling pointed me at fairly recent Stack Overflow answers &lt;a href=&#34;http://stackoverflow.com/a/36526153/4499783&#34;&gt;like this one&lt;/a&gt; that suggested the following:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Move the &lt;code&gt;buildscript&lt;/code&gt; kotlin classpath dependencies to the app module&amp;rsquo;s &lt;code&gt;build.gradle&lt;/code&gt; file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apply plugin: &#39;kotlin-android-extensions&#39;&lt;/code&gt; and add &lt;code&gt;classpath &amp;quot;org.jetbrains.kotlin:kotlin-android-extensions:$kotlin_version&amp;quot;&lt;/code&gt; in the gradle file&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In fact, the &lt;a href=&#34;https://kotlinlang.org/docs/tutorials/android-plugin.html#using-kotlin-android-extensions&#34;&gt;official docs&lt;/a&gt; do say you need to apply the &lt;code&gt;kotlin-android-extensions&lt;/code&gt; plugin. We should do this. Better safe than sorry, right?&lt;/p&gt;

&lt;p&gt;However, I think it&amp;rsquo;s worth noting that these tips did &lt;em&gt;not&lt;/em&gt; fix the conflicts I ran into above with my current setup (Android Studio 2.2-preview3/Dagger 2.2/Kotlin 1.0.2), and that after turning minify off the standard setup (i.e. &lt;code&gt;buildscript&lt;/code&gt; in project root &lt;code&gt;build.gradle&lt;/code&gt;; no explicit mention of &lt;code&gt;kotlin-android-extensions&lt;/code&gt;) everything worked perfectly. Again, this may vary based on what tool versions you are using.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update 2016-06-15:&lt;/strong&gt; Using Dagger 2.4 did not solve this problem.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update 2016-10-05:&lt;/strong&gt; In Kotlin plugin v1.0.3 and up, the automatic project setup works without modification.&lt;/p&gt;

&lt;h3 id=&#34;inject-requires-the-exact-class-you-re-injecting-into:8b618abf5a7523d1736f50f60d1b5347&#34;&gt;&lt;code&gt;inject()&lt;/code&gt; requires the &lt;em&gt;exact&lt;/em&gt; class you&amp;rsquo;re injecting into&lt;/h3&gt;

&lt;p&gt;Lastly, my &amp;ldquo;d&amp;rsquo;oh!&amp;rdquo; moment.&lt;/p&gt;

&lt;p&gt;One of my Activities implemented an interface for interaction with its presenter:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;TimerActivity.kt&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class TimerActivity : AppCompatActivity(), TimerContract.TimerView {

    @Inject
    override lateinit var presenter: TimerContract.UserActionsListener
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;TimerPresenter.kt&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class TimerPresenter
    @Inject constructor(override var view: TimerContract.TimerView)
    : TimerContract.UserActionsListener {
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I wanted to inject the presenter in &lt;code&gt;TimerActivity&lt;/code&gt; using Dagger, so I implemented a module and component for it.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;TimerComponent.kt&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import dagger.Component

@Component(
        modules = arrayOf(TimerModule::class)
)
interface TimerComponent {

    fun inject(timerView: TimerContract.TimerView)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;TimerActivity.kt&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class TimerActivity : AppCompatActivity(), TimerContract.TimerView {

    @Inject
    override lateinit var presenter: TimerContract.UserActionsListener
    ...

    override fun onCreate(savedInstanceState: Bundle) {
        super.onCreate(savedInstanceState)
        // Inject away!
        DaggerTimerComponent.builder()
            .timerModule(TimerModule(this))
            .build()
            .inject(this)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It type-checks and everything! But &lt;code&gt;presenter&lt;/code&gt; still wasn&amp;rsquo;t getting injected. Did you see the problem?&lt;/p&gt;

&lt;p&gt;Despite &lt;code&gt;inject()&lt;/code&gt; type checking for a &lt;code&gt;TimerActivity&lt;/code&gt; that conforms to the &lt;code&gt;TimerContract.TimerView&lt;/code&gt; interface, it turns out that the method much match the type of the injecting object exactly.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;TimerComponent.kt&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import dagger.Component

@Component(
        modules = arrayOf(TimerModule::class)
)
interface TimerComponent {

//  fun inject(timerView: TimerContract.TimerView) Nope!
    fun inject(timerActivity: TimerActivity)    // Yup!
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Total noob move, I&amp;rsquo;m sure, but hey, now I know.&lt;/p&gt;

&lt;h2 id=&#34;helpful-resources:8b618abf5a7523d1736f50f60d1b5347&#34;&gt;Helpful Resources&lt;/h2&gt;

&lt;p&gt;I probably wouldn&amp;rsquo;t have figured out how to make everything work without the help of the following resources &amp;ndash; props to the makers:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;damianpetla&amp;rsquo;s &lt;a href=&#34;https://github.com/damianpetla/kotlin-dagger-example&#34;&gt;kotlin-dagger-example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Google&amp;rsquo;s example &lt;a href=&#34;https://github.com/googlesamples/android-architecture/tree/todo-mvp-dagger&#34;&gt;MVP+Dagger architected ToDo App&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;soflete&amp;rsquo;s &lt;a href=&#34;http://soflete.github.io/2016/04/01/Android-MVP-with-Dagger/&#34;&gt;Android with Dagger&lt;/a&gt; example&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Update 2016-10-05:&lt;/strong&gt; I now have my own working Kotlin/Dagger app &lt;a href=&#34;https://github.com/ronaldsmartin/20twenty20&#34;&gt;on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Thanks for reading, and catch you next time!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>